
#### Node高性能原因：
&emsp;&emsp;在于事件(Event)的使用，以及对于事件监听者(listener,callback) 的调用

#### Node事件循环机制：
&emsp;&emsp;Node本身是基于事件循环机制的.本质上在Node启动后,是运行在一个死循环中.

```js
    while(true){
      ...
    }
```

在死循环中,Node在不断的发射，监听事件，执行回调逻辑

#### Node完整事件循环逻辑：
 1. 启动Node运行时
 2. 检测是否有带处理的事件
 3. 没有,回到循环开始
 4. 有,从事件队列中取出一个事件进行处理
 5. 判断当前事件是否有关联的回调
 6. 没有,回到循环开始
 7. 有,执行事件的回调逻辑
 8. 回调循环开始,开始新一轮事件检测流程

#### 事件来源：
 1. Node自身所发射的事件（用户自定义事件）
 2. 来自于Node自身所运行的环境（如：系统回调事件）

#### 监听事件：
&emsp;&emsp;回调都需要依附于相应事件上

#### 执行回调逻辑：
&emsp;&emsp;本质上都是由底层来执行的

#### 关于IO操作的异步执行逻辑：
  1. 同步模式
  2. 异步模式
        Linux：`poll`、`epoll`（Node用的是更高效的`epoll`）
                `epoll`用于处理大批量文件描述符,主要处理IO相关操作
        Windows：`IOCP`（Input/Output Completion Port）输入输出完成端口
                  支持多个同时发生的异步I/O操作的应用程序编程接口
    
 > libuv：开发node的过程中需要一个跨平台的事件库，他们首选了`libev`，但又要支持Windows，故重新封装了一套，linux下用libev实现，Windows下用`IOCP`实现. 
            `libuv` 采用了 异步 (asynchronous), 事件驱动 (event-driven)的编程风格, 其主要任务是为开人员提供了一套事件循环和基于I/O(或其他活动)通知的回调函数, `libuv` 提供了一套核心的工具集, 例如定时器, 非阻塞网络编程的支持, 异步访问文件系统, 子进程以及其他功能.

#### Node的单线程：
&emsp;&emsp;所谓单线程指的是Node的逻辑执行的主线程是单线程，既Javascript代码运行所处的线程，这是单线程，因为Javascript本身只能执行在单线程当中.

#### Node使用第三方模块的执行逻辑：
  `Node` -> `第三方模块` -> `原生模块` -> `原生模块内部的实现` -> `C++模块` -> `libuv` -> `线程池` -> `线程` -> `执行底层IO操作（涉及到操作系统调用）`

  当Node在执行过程中，会先判断当前操作系统类型，linux用`libuv`，windows用`IOCP`

#### 整个Node执行过程实际以下三大块共同配合来完成的：
&emsp;&emsp;事件循环机制 + 底层的异步IO调用 + 线程池(底层库实现或由操作系统提供) 

#### 对于单线程的Node来说，是否无法利用多核CPU的优势？
- 对于Node的主线程来说，是无法利用多核优势的.  
- 对于底层的线程池来说，它是可以运行在多核心上的,也可以同时运行